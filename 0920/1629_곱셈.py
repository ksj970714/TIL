'''
들어가는 수가 크기에, 일반적인 방법으로는 시간이 너무 오래 걸려 시간초과가 난다.
따라서, 효율적인 알고리즘이 필요함.
X를 Z로 나눈 나머지를 x라고 하고, Y를 Z로 나눈 나머지를 y라고 할 때,
(X*Y)%Z는 (x*y)%z와 같다.
따라서, A**B에 대해 분할 정복 알고리즘을 적용시키면 풀 수 있다.
B**8을 구할 때, B*B*......*B로 구하면 굉장히 오래 걸리지만,
((B**2)**2)**2)로 구하면 계산횟수를 줄일 수 있다. 이에 착안해 알고리즘을 크게 두 단계로 설계한다.

1-1. A를 C로 나눴을 때 나머지를 temp에 저장해준다. 이는 B = 1, 즉 2**0일때 값이므로,
이를 나머지를 저장하는 reminder 리스트에 append 해준다.

1-2. temp를 제곱해준다. 이는 B = 2일때 C로 나눈 나머지이다. reminder에 append 해준다.
추후 인덱싱 할 때, reminder[1]일 때 B = 2**1일 때 C로 나눈 나머지를 알 수 있다.

1-3. 계속 반복한다. B = 4일때 reminder[2]에 C로 나눈 나머지가 저장... 반복

1-4. 2**n (n은 정수) < B < 2**(n+1)이 되는 n까지 저장해준다.
그러한 n은 int(log 2 (B)) 하면 소수점 이하는 버림이 된다.

2-1.
지수인 B를 "2의 제곱수" 들의 합으로 변환한다.
예를 들면, B = 400인 경우, B = 256+128+16이다.

2-2. 이러한 과정을 다음과 같이 구현한다.
logb 변수에 위의 n이 저장되어있다.

B > 2**(n)인 경우,
    B = B - 2**(n)
    rem(나머지의 곱을 저장하는 변수)에 reminder[n]을 곱해줌.
n -= 1

400을 예로 들면 다음과 같다.
n = 8부터 시작
n = 8일때 400 > 256이므로 ; B = 400 - 256 = 144 ; rem *= reminder[8]
n = 7일때 144 > 128이므로 ; B = 144 - 128 =  16 ; rem *= reminder[7]
n = 6일때 16 > 64이므로, 코드 수행하지 않음

이를 while문으로 구현한다.

2-3. 이후, rem에 (A**256%C)*(A**128%C)*(A**16%C)이 담겨있게 되는데,
이 rem은 충분히 작아진 값이므로
한번 더 % 연산을 통해 나머지를 구해주면 된다.
'''
import math

A, B, C = map(int,input().split())

logb = int(math.log2(B))+1

reminder = []
temp = A
for i in range(logb+1):
    temp = (temp)%C
    reminder.append(temp)
    temp = temp*temp

rem = 1
k = B
while logb >= 0:
    if k >= 2**logb :
        rem *= reminder[logb]
        k = k-(2**(logb))
    logb -= 1


print(rem%C)